# GWT ãƒãƒˆãƒ«ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆã‚¬ã‚¤ãƒ‰ ğŸ’»
## ï½è¦–è¦šã¡ã‚ƒã‚“ãƒ»è´è¦šãã‚“ãƒ»è¨€èªã•ã‚“ãƒ»è¨˜æ†¶ã¡ã‚ƒã‚“ã®ãƒãƒˆãƒ«ä¼šå ´ã‚’ä½œã£ã¡ã‚ƒãŠï½

> **ä»Šå›ã®ãƒŸãƒƒã‚·ãƒ§ãƒ³**: 4äººã®ãƒ—ãƒ­ã‚»ãƒƒã‚µã¡ã‚ƒã‚“ãŸã¡ãŒç«¶äº‰ã§ãã‚‹ãƒãƒˆãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿéš›ã«ä½œã‚‹ï¼
> ç†è«–ã¯åˆ†ã‹ã£ãŸã€ã‚­ãƒ£ãƒ©ã‚‚åˆ†ã‹ã£ãŸã€ã˜ã‚ƒã‚å®Ÿéš›ã®ãƒãƒˆãƒ«ä¼šå ´ã¯ã©ã†è¨­è¨ˆã™ã‚‹ã®ï¼Ÿ ğŸŸï¸

---

## ğŸŸï¸ ãƒãƒˆãƒ«ä¼šå ´ã®å…¨ä½“è¨­è¨ˆ

### åŠ‡å ´ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹æˆ - ã¿ã‚“ãªã®é…ç½®

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ğŸ‘¥ è¦³å®¢å¸­ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ï¼‰                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚            åŠ‡å ´è¦³è¦§ã‚·ã‚¹ãƒ†ãƒ ï¼ˆReactï¼‰              â”‚   â”‚
â”‚  â”‚                                                 â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ğŸ­ ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ã‚¸â”‚  â”‚ ğŸ“Š ãƒãƒˆãƒ«è¦³æˆ¦ãƒ‘ãƒãƒ«      â”‚  â”‚   â”‚
â”‚  â”‚  â”‚(ãƒãƒˆãƒ«å®Ÿæ³ä¸­ç¶™)â”‚  â”‚ - é¸æ‰‹å…¥å ´ã‚²ãƒ¼ãƒˆ        â”‚  â”‚   â”‚
â”‚  â”‚  â”‚             â”‚  â”‚ - é¸æ‰‹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º    â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ ğŸ‘ï¸ ğŸ‘‚ ğŸ’¬ ğŸ§ â”‚  â”‚ - ãƒãƒˆãƒ«å±¥æ­´           â”‚  â”‚   â”‚
â”‚  â”‚  â”‚             â”‚  â”‚ - å¯©åˆ¤ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«       â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†• å®Ÿæ³ä¸­ç¶™å›ç·šï¼ˆWebSocketï¼‰
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 ğŸŸï¸ ãƒãƒˆãƒ«ã‚¢ãƒªãƒ¼ãƒŠï¼ˆã‚µãƒ¼ãƒãƒ¼ï¼‰               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚               ãƒãƒˆãƒ«é‹å–¶æœ¬éƒ¨                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚              é¸æ‰‹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ                  â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”‚ é¸æ‰‹æ§ãˆå®¤    â”‚  â”‚ ğŸ† ãƒãƒˆãƒ«å¯©åˆ¤ã‚·ã‚¹ãƒ†ãƒ  â”‚  â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”‚ğŸ‘ï¸è¦–è¦šã¡ã‚ƒã‚“   â”‚  â”‚- ç«¶äº‰ãƒ«ãƒ¼ãƒ«ç®¡ç†     â”‚  â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”‚ğŸ‘‚è´è¦šãã‚“     â”‚  â”‚- ã‚¹ã‚³ã‚¢è¨ˆç®—        â”‚  â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”‚ğŸ’¬è¨€èªã•ã‚“     â”‚  â”‚- å‹è€…åˆ¤å®š          â”‚  â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”‚ğŸ§ è¨˜æ†¶ã¡ã‚ƒã‚“   â”‚  â”‚- çµæœç™ºè¡¨          â”‚  â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚  â”‚         ğŸª ãƒãƒˆãƒ«ã‚¹ãƒ†ãƒ¼ã‚¸ç®¡ç†            â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  - å®Ÿæ³ä¸­ç¶™ã‚·ã‚¹ãƒ†ãƒ                      â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  - ãƒãƒˆãƒ«å±¥æ­´è¨˜éŒ²                       â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  - ãƒ•ã‚¡ãƒ³æŠ•ç¥¨ã‚·ã‚¹ãƒ†ãƒ                     â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### é¸æ‰‹ç´¹ä»‹ - ãƒãƒˆãƒ©ãƒ¼4äººçµ„

| é¸æ‰‹å | ãƒã‚¸ã‚·ãƒ§ãƒ³ | å¾—æ„æŠ€ | æ€§æ ¼ |
|-------|-----------|-------|------|
| **ğŸ‘ï¸ è¦–è¦šã¡ã‚ƒã‚“** | ã‚¢ã‚¿ãƒƒã‚«ãƒ¼ | è‰²ãƒ»å½¢ãƒ»å‹•ãã®ç¬é–“èªè­˜ | å®Œç’§ä¸»ç¾©ã€ç´°ã‹ã„ã¨ã“ã¾ã§æ°—ã¥ã |
| **ğŸ‘‚ è´è¦šãã‚“** | ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ãƒ€ãƒ¼ | éŸ³ã®æ–¹å‘ãƒ»ç·Šæ€¥åº¦åˆ¤å®š | æ•æ„Ÿã€ç©ºæ°—èª­ã‚€ã®å¾—æ„ |
| **ğŸ’¬ è¨€èªã•ã‚“** | ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ã‚¹ãƒˆ | æ–‡ç« ç†è§£ãƒ»ä¼šè©±åˆ†æ | è«–ç†çš„ã€èª¬æ˜ä¸Šæ‰‹ |
| **ğŸ§  è¨˜æ†¶ã¡ã‚ƒã‚“** | ã‚µãƒãƒ¼ã‚¿ãƒ¼ | éå»ãƒ‡ãƒ¼ã‚¿æ¤œç´¢ãƒ»é–¢é€£ä»˜ã‘ | åšè­˜ã€é€£æƒ³ã‚²ãƒ¼ãƒ ã®å¥³ç‹ |

---

## âš”ï¸ ãƒãƒˆãƒ«ä¼šå ´ã®ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆ

### 1. é¸æ‰‹æ§ãˆå®¤ã®å®Ÿè£… - ãƒ—ãƒ­ã‚»ãƒƒã‚µãŸã¡ã®å¾…æ©Ÿå ´æ‰€

```typescript
// src/processors/VisionProcessor.ts - è¦–è¦šã¡ã‚ƒã‚“ã®æ§ãˆå®¤
export class VisionProcessor implements Processor {
  id = 'vision';
  nickname = 'è¦–è¦šã¡ã‚ƒã‚“';
  personality = 'perfectionist';

  private currentMood = 'ready';        // ä»Šã®æ°—åˆ†
  private battleHistory: Battle[] = []; // æˆ¦ç¸¾
  private rivals = ['audio'];           // ãƒ©ã‚¤ãƒãƒ«é–¢ä¿‚

  // ã€Œã“ã®ãƒãƒˆãƒ«ã€ç§ãŒå‡ºã‚‹ï¼Ÿã€
  canHandle(battleInput: ProcessorInput): boolean {
    console.log('ğŸ‘ï¸ è¦–è¦šã¡ã‚ƒã‚“: ã“ã®ãƒãƒˆãƒ«è¦‹ã¦ã¿ã‚‹...');

    // è¦–è¦šçš„ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    const visualKeywords = ['è¦‹ã‚‹', 'è‰²', 'å…‰', 'å½¢', 'ç¾ã—ã„', 'ã‚­ãƒ¬ã‚¤'];
    const hasVisualContent = visualKeywords.some(keyword =>
      battleInput.data.includes(keyword)
    );

    if (hasVisualContent) {
      console.log('ğŸ‘ï¸ è¦–è¦šã¡ã‚ƒã‚“: ã“ã‚Œã¯ç§ã®å‡ºç•ªã­ï¼âœ¨');
      this.currentMood = 'excited';
      return true;
    }

    console.log('ğŸ‘ï¸ è¦–è¦šã¡ã‚ƒã‚“: ã†ãƒ¼ã‚“ã€ä»Šå›ã¯ãƒ‘ã‚¹ã‹ãª');
    return battleInput.type === 'vision';
  }

  // ã€Œã‚ˆã—ã€ãƒãƒˆãƒ«é–‹å§‹ï¼ã€
  async process(battleInput: ProcessorInput): Promise<ProcessorOutput> {
    const battleStart = Date.now();
    console.log('ğŸ‘ï¸ è¦–è¦šã¡ã‚ƒã‚“: ãƒãƒˆãƒ«å‚æˆ¦ï¼å®Œç’§ã«åˆ†æã—ã¦ã¿ã›ã‚‹');

    // è¦–è¦šåˆ†æãƒãƒˆãƒ«é–‹å§‹
    const analysis = await this.analyzeWithPerfectionism(battleInput.data);

    // è‡ªä¿¡åº¦è¨ˆç®—ï¼ˆå®Œç’§ä¸»ç¾©ã‚‰ã—ãæ…é‡ã«ï¼‰
    const confidence = this.calculatePerfectionistConfidence(analysis);

    // ãƒãƒˆãƒ«çµæœã‚’è¨˜éŒ²
    const battleResult = {
      processorId: this.id,
      nickname: this.nickname,
      confidence,
      content: {
        visualAnalysis: analysis,
        mood: this.currentMood,
        battleCry: 'å®Œç’§ãªåˆ†æã§å‹åˆ©ã‚’æ´ã‚€ï¼'
      },
      processingTime: Date.now() - battleStart,
      priority: this.calculateVisualPriority(analysis)
    };

    console.log(`ğŸ‘ï¸ è¦–è¦šã¡ã‚ƒã‚“: åˆ†æå®Œäº†ï¼è‡ªä¿¡åº¦${(confidence * 100).toFixed(1)}%`);
    return battleResult;
  }

  // ã€Œä»–ã®é¸æ‰‹ã®å‹åˆ©ã‚’è¦‹ã‚‹...ã€
  onGlobalBroadcast(battleResult: ConsciousContent): void {
    const winner = battleResult.winner;

    if (winner.processorId === this.id) {
      console.log('ğŸ‘ï¸ è¦–è¦šã¡ã‚ƒã‚“: ã‚„ã£ãŸãƒ¼ï¼å®Œç’§ãªå‹åˆ©âœ¨');
      this.currentMood = 'victorious';
      this.updateBattleHistory('win', battleResult);
    } else {
      console.log(`ğŸ‘ï¸ è¦–è¦šã¡ã‚ƒã‚“: ${winner.nickname}ã®å‹åˆ©ã‹ã...æ¬¡ã¯è² ã‘ãªã„ï¼`);
      this.currentMood = 'determined';
      this.updateBattleHistory('loss', battleResult);
      this.learnFromDefeat(winner);
    }
  }

  // å®Œç’§ä¸»ç¾©è€…ã‚‰ã—ã„åˆ†æ
  private async analyzeWithPerfectionism(data: string): Promise<any> {
    // ç´°ã‹ãä¸å¯§ã«åˆ†æ
    const colors = this.extractColors(data);
    const shapes = this.identifyShapes(data);
    const aesthetics = this.evaluateBeauty(data);

    return { colors, shapes, aesthetics, detailLevel: 'maximum' };
  }

  // è‡ªä¿¡åº¦è¨ˆç®—ï¼ˆå®Œç’§ä¸»ç¾©è€…ã¯æ…é‡ï¼‰
  private calculatePerfectionistConfidence(analysis: any): number {
    let confidence = 0.3; // åŸºæœ¬ã¯æ§ãˆã‚

    if (analysis.detailLevel === 'maximum') confidence += 0.4;
    if (analysis.aesthetics.score > 0.8) confidence += 0.3;

    return Math.min(confidence, 0.95); // 100%ã¯è¨€ã‚ãªã„è¬™è™šã•
  }
}
```

```typescript
// src/processors/AudioProcessor.ts - è´è¦šãã‚“ã®æ§ãˆå®¤
export class AudioProcessor implements Processor {
  id = 'audio';
  nickname = 'è´è¦šãã‚“';
  personality = 'sensitive';

  private alertLevel = 'normal';        // è­¦æˆ’ãƒ¬ãƒ™ãƒ«
  private soundMemory: Sound[] = [];    // éŸ³ã®è¨˜æ†¶

  canHandle(battleInput: ProcessorInput): boolean {
    console.log('ğŸ‘‚ è´è¦šãã‚“: ã©ã‚“ãªéŸ³ã‹ãªï¼Ÿèã„ã¦ã¿ã‚ˆã†...');

    // éŸ³é–¢ä¿‚ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚„ç·Šæ€¥æ€§ã‚’ãƒã‚§ãƒƒã‚¯
    const audioKeywords = ['éŸ³', 'å£°', 'éŸ³æ¥½', '!', 'ï¼Ÿ', 'ç·Šæ€¥', 'åŠ©ã‘ã¦'];
    const urgentMarkers = ['ï¼', '!', 'ç·Šæ€¥', 'ãƒ¤ãƒã„', 'å¤§å¤‰'];

    const hasAudioContent = audioKeywords.some(keyword =>
      battleInput.data.includes(keyword)
    );
    const isUrgent = urgentMarkers.some(marker =>
      battleInput.data.includes(marker)
    );

    if (isUrgent) {
      console.log('ğŸ‘‚ è´è¦šãã‚“: ç·Šæ€¥äº‹æ…‹ï¼ï¼Ÿã“ã‚Œã¯åƒ•ã®å‡ºç•ªã ï¼');
      this.alertLevel = 'high';
      return true;
    }

    if (hasAudioContent) {
      console.log('ğŸ‘‚ è´è¦šãã‚“: éŸ³ã®åˆ†æã€å¾—æ„ã ã‚ˆâ™ª');
      return true;
    }

    return battleInput.type === 'audio';
  }

  async process(battleInput: ProcessorInput): Promise<ProcessorOutput> {
    const battleStart = Date.now();
    console.log('ğŸ‘‚ è´è¦šãã‚“: éŸ³ã®ä¸–ç•Œã«é›†ä¸­...ãƒãƒˆãƒ«é–‹å§‹ï¼');

    // è´è¦šåˆ†æï¼ˆæ•æ„Ÿã«ï¼‰
    const soundAnalysis = await this.sensitiveAnalysis(battleInput.data);

    // ç·Šæ€¥åº¦åˆ¤å®šï¼ˆã“ã‚ŒãŒè´è¦šãã‚“ã®ç‰¹æŠ€ï¼‰
    const urgencyLevel = this.detectUrgency(battleInput.data);

    const confidence = this.calculateSensitiveConfidence(soundAnalysis, urgencyLevel);

    const battleResult = {
      processorId: this.id,
      nickname: this.nickname,
      confidence,
      content: {
        soundAnalysis,
        urgencyLevel,
        alertLevel: this.alertLevel,
        battleCry: 'éŸ³ã®ä¸–ç•Œã§èª°ã«ã‚‚è² ã‘ãªã„ï¼'
      },
      processingTime: Date.now() - battleStart,
      priority: urgencyLevel * 0.8 + 0.2 // ç·Šæ€¥åº¦é‡è¦–
    };

    console.log(`ğŸ‘‚ è´è¦šãã‚“: ç·Šæ€¥åº¦${urgencyLevel}, è‡ªä¿¡åº¦${(confidence * 100).toFixed(1)}%`);
    return battleResult;
  }

  onGlobalBroadcast(battleResult: ConsciousContent): void {
    const winner = battleResult.winner;

    if (winner.processorId === this.id) {
      console.log('ğŸ‘‚ è´è¦šãã‚“: åƒ•ã®æ„Ÿåº¦ãŒå‹ã£ãŸï¼å¬‰ã—ã„ãªâ™ª');
      this.alertLevel = 'satisfied';
    } else {
      console.log(`ğŸ‘‚ è´è¦šãã‚“: ${winner.nickname}ã™ã”ã„ãªã...åƒ•ã‚‚é ‘å¼µã‚ã†`);
      this.alertLevel = 'motivated';
    }
  }

  // æ•æ„Ÿãªåˆ†æï¼ˆè´è¦šãã‚“ã®ç‰¹æŠ€ï¼‰
  private async sensitiveAnalysis(data: string): Promise<any> {
    const volume = this.estimateVolume(data);      // éŸ³é‡æ¨å®š
    const tone = this.analyzeTone(data);           // ãƒˆãƒ¼ãƒ³åˆ†æ
    const emotion = this.detectEmotion(data);      // æ„Ÿæƒ…æ¤œå‡º

    return { volume, tone, emotion, sensitivity: 'maximum' };
  }

  // ç·Šæ€¥åº¦æ¤œå‡ºï¼ˆè´è¦šãã‚“ã®è¶…èƒ½åŠ›ï¼‰
  private detectUrgency(data: string): number {
    const urgentWords = ['ç·Šæ€¥', 'åŠ©ã‘ã¦', 'å±é™º', 'æ€¥ã„ã§', 'ãƒ¤ãƒã„'];
    const exclamationCount = (data.match(/[!ï¼]/g) || []).length;

    let urgency = 0;
    urgentWords.forEach(word => {
      if (data.includes(word)) urgency += 0.3;
    });
    urgency += exclamationCount * 0.2;

    return Math.min(urgency, 1.0);
  }
}
```

### 2. å¯©åˆ¤ã‚·ã‚¹ãƒ†ãƒ  - ãƒãƒˆãƒ«ã®å‹è€…ã‚’æ±ºã‚ã‚‹

```typescript
// src/AttentionManager.ts - ãƒãƒˆãƒ«ã®å¯©åˆ¤é•·
export class BattleJudge {
  private battleHistory: BattleRecord[] = [];
  private currentSeason = 'Season1';

  // ã€Œã•ãã€ãƒãƒˆãƒ«é–‹å§‹ï¼ã€
  judgeBattle(contestants: ProcessorOutput[]): ConsciousContent {
    console.log('ğŸ† å¯©åˆ¤é•·: ãƒãƒˆãƒ«é–‹å§‹ï¼å‚åŠ è€…æ•°:', contestants.length);

    // å„é¸æ‰‹ã®ã‚¹ã‚³ã‚¢è¨ˆç®—
    const battleScores = contestants.map(contestant => {
      const score = this.calculateBattleScore(contestant);
      console.log(`ğŸ“Š ${contestant.nickname}: ${score.toFixed(2)}ç‚¹`);

      return {
        contestant,
        battleScore: score,
        breakdown: this.getScoreBreakdown(contestant)
      };
    });

    // ã‚¹ã‚³ã‚¢é †ã§ã‚½ãƒ¼ãƒˆ
    battleScores.sort((a, b) => b.battleScore - a.battleScore);

    const champion = battleScores[0];
    const runners = battleScores.slice(1);

    console.log(`ğŸ† å¯©åˆ¤é•·: å‹è€…ã¯${champion.contestant.nickname}ï¼`);

    // ãƒãƒˆãƒ«çµæœã‚’ä½œæˆ
    const battleResult: ConsciousContent = {
      winner: champion.contestant,
      competitors: runners.map(r => r.contestant),
      timestamp: Date.now(),
      globalState: {
        battleIntensity: this.calculateBattleIntensity(battleScores),
        championModality: champion.contestant.processorId,
        season: this.currentSeason,
        battleType: this.determineBattleType(contestants)
      }
    };

    // æˆ¦æ­´ã«è¨˜éŒ²
    this.recordBattle(battleResult, battleScores);

    return battleResult;
  }

  // ãƒãƒˆãƒ«ã‚¹ã‚³ã‚¢è¨ˆç®—ã‚·ã‚¹ãƒ†ãƒ 
  private calculateBattleScore(contestant: ProcessorOutput): number {
    const weights = {
      confidence: 0.35,     // è‡ªä¿¡åº¦
      priority: 0.40,       // å„ªå…ˆåº¦
      speed: 0.15,         // ã‚¹ãƒ”ãƒ¼ãƒ‰
      personality: 0.10    // å€‹æ€§ãƒœãƒ¼ãƒŠã‚¹
    };

    const baseScore = (
      contestant.confidence * weights.confidence +
      contestant.priority * weights.priority +
      this.calculateSpeedScore(contestant.processingTime) * weights.speed
    );

    // å€‹æ€§ãƒœãƒ¼ãƒŠã‚¹
    const personalityBonus = this.calculatePersonalityBonus(contestant);

    // æœ€è¿‘ã®æˆ¦ç¸¾ãƒœãƒ¼ãƒŠã‚¹
    const recentPerformance = this.getRecentPerformanceBonus(contestant.processorId);

    const finalScore = baseScore + personalityBonus + recentPerformance;

    console.log(`ğŸ“ˆ ${contestant.nickname}ã®ã‚¹ã‚³ã‚¢è©³ç´°:
      - ãƒ™ãƒ¼ã‚¹: ${baseScore.toFixed(2)}
      - å€‹æ€§ãƒœãƒ¼ãƒŠã‚¹: ${personalityBonus.toFixed(2)}
      - æˆ¦ç¸¾ãƒœãƒ¼ãƒŠã‚¹: ${recentPerformance.toFixed(2)}
      - æœ€çµ‚: ${finalScore.toFixed(2)}`);

    return finalScore;
  }

  // å€‹æ€§ãƒœãƒ¼ãƒŠã‚¹è¨ˆç®—
  private calculatePersonalityBonus(contestant: ProcessorOutput): number {
    const personality = contestant.content?.personality || contestant.processorId;

    switch (personality) {
      case 'perfectionist': // è¦–è¦šã¡ã‚ƒã‚“
        return contestant.content?.detailLevel === 'maximum' ? 0.1 : 0;
      case 'sensitive': // è´è¦šãã‚“
        return contestant.content?.urgencyLevel > 0.7 ? 0.15 : 0;
      case 'logical': // è¨€èªã•ã‚“
        return contestant.content?.logicalStructure ? 0.1 : 0;
      case 'wise': // è¨˜æ†¶ã¡ã‚ƒã‚“
        return contestant.content?.connectionCount > 3 ? 0.12 : 0;
      default:
        return 0;
    }
  }

  // ãƒãƒˆãƒ«ã®æ¿€ã—ã•è¨ˆç®—
  private calculateBattleIntensity(battleScores: any[]): number {
    if (battleScores.length < 2) return 0;

    const topScore = battleScores[0].battleScore;
    const secondScore = battleScores[1].battleScore;

    // ã‚¹ã‚³ã‚¢å·®ãŒå°ã•ã„ã»ã©æ¿€æˆ¦
    const scoreDiff = topScore - secondScore;
    const intensity = Math.max(0, 1 - (scoreDiff / 0.5));

    console.log(`âš”ï¸ ãƒãƒˆãƒ«æ¿€ã—ã•: ${(intensity * 100).toFixed(1)}% (ã‚¹ã‚³ã‚¢å·®: ${scoreDiff.toFixed(3)})`);

    return intensity;
  }
}
```

### 3. å®Ÿæ³ä¸­ç¶™ã‚·ã‚¹ãƒ†ãƒ  - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¦³æˆ¦

```typescript
// src/GlobalWorkspace.ts - ãƒãƒˆãƒ«é‹å–¶æœ¬éƒ¨
export class BattleArena extends EventEmitter {
  private contestants: Processor[] = [];
  private battleJudge: BattleJudge;
  private broadcaster: BattleBroadcaster;
  private fanClub: FanClub;

  constructor() {
    super();
    this.setupContestants();
    this.battleJudge = new BattleJudge();
    this.broadcaster = new BattleBroadcaster();
    this.fanClub = new FanClub();
  }

  // ã€Œãƒãƒˆãƒ«é–‹å§‹ã®åˆå›³ï¼ã€
  async startBattle(challenge: ProcessorInput | ProcessorInput[]): Promise<ConsciousContent> {
    console.log('ğŸª ãƒãƒˆãƒ«ã‚¢ãƒªãƒ¼ãƒŠ: æ–°ã—ã„ãƒãƒˆãƒ«é–‹å§‹ï¼');
    this.broadcaster.announceStart(challenge);

    // 1. é¸æ‰‹ã‚¨ãƒ³ãƒˆãƒªãƒ¼å—ä»˜
    const entries = await this.acceptEntries(challenge);
    console.log(`ğŸ‘¥ ã‚¨ãƒ³ãƒˆãƒªãƒ¼å—ä»˜å®Œäº†: ${entries.length}åå‚åŠ `);

    // 2. ãƒãƒˆãƒ«å®Ÿè¡Œï¼ˆä¸¦åˆ—ãƒãƒˆãƒ«ï¼‰
    const battleResults = await this.conductParallelBattle(entries);
    console.log('âš”ï¸ ãƒãƒˆãƒ«çµ‚äº†ã€çµæœé›†è¨ˆä¸­...');

    // 3. å¯©åˆ¤ã«ã‚ˆã‚‹åˆ¤å®š
    const finalResult = this.battleJudge.judgeBattle(battleResults);
    console.log(`ğŸ† å‹è€…æ±ºå®š: ${finalResult.winner.nickname}`);

    // 4. å®Ÿæ³ä¸­ç¶™
    this.broadcaster.announceResult(finalResult);

    // 5. ãƒ•ã‚¡ãƒ³ã¸ã®çµæœé€šçŸ¥
    this.fanClub.notifyResult(finalResult);

    // 6. å…¨é¸æ‰‹ã¸ã®çµæœå…±æœ‰
    this.shareResultWithAll(finalResult);

    return finalResult;
  }

  // é¸æ‰‹ã‚¨ãƒ³ãƒˆãƒªãƒ¼å—ä»˜
  private async acceptEntries(challenge: ProcessorInput | ProcessorInput[]): Promise<ProcessorOutput[]> {
    const challenges = Array.isArray(challenge) ? challenge : [challenge];
    const entryPromises: Promise<ProcessorOutput>[] = [];

    console.log('ğŸ“ ã‚¨ãƒ³ãƒˆãƒªãƒ¼å—ä»˜é–‹å§‹...');

    for (const singleChallenge of challenges) {
      // å„ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã«å¯¾ã—ã¦å¯¾å¿œå¯èƒ½ãªé¸æ‰‹ã‚’å‹Ÿé›†
      const eligibleContestants = this.contestants.filter(contestant => {
        const canJoin = contestant.canHandle(singleChallenge);
        if (canJoin) {
          console.log(`âœ‹ ${contestant.nickname}: ã‚¨ãƒ³ãƒˆãƒªãƒ¼è¡¨æ˜ï¼`);
        }
        return canJoin;
      });

      // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã—ãŸé¸æ‰‹ãŸã¡ã®ãƒãƒˆãƒ«æº–å‚™
      for (const contestant of eligibleContestants) {
        entryPromises.push(contestant.process(singleChallenge));
      }
    }

    // å…¨å“¡ã®ãƒãƒˆãƒ«æº–å‚™å®Œäº†ã‚’å¾…ã¤
    return Promise.all(entryPromises);
  }

  // ä¸¦åˆ—ãƒãƒˆãƒ«å®Ÿè¡Œ
  private async conductParallelBattle(entries: Promise<ProcessorOutput>[]): Promise<ProcessorOutput[]> {
    console.log('âš”ï¸ ä¸¦åˆ—ãƒãƒˆãƒ«é–‹å§‹ï¼');
    const startTime = Date.now();

    // Promise.all ã§åŒæ™‚ãƒãƒˆãƒ«å®Ÿè¡Œ
    const results = await Promise.all(entries);

    const battleDuration = Date.now() - startTime;
    console.log(`â±ï¸ ãƒãƒˆãƒ«æ™‚é–“: ${battleDuration}ms`);

    return results;
  }

  // çµæœã‚’ã¿ã‚“ãªã«å…±æœ‰
  private shareResultWithAll(result: ConsciousContent): void {
    console.log('ğŸ“¢ å…¨é¸æ‰‹ã«çµæœã‚’å…±æœ‰ä¸­...');

    this.contestants.forEach(contestant => {
      contestant.onGlobalBroadcast(result);
    });

    // è¦³å®¢ï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ï¼‰ã«ã‚‚å®Ÿæ³ä¸­ç¶™
    this.emit('battle-result', result);
  }
}

// å®Ÿæ³ã‚¢ãƒŠã‚¦ãƒ³ã‚µãƒ¼
class BattleBroadcaster {
  announceStart(challenge: any): void {
    console.log('ğŸ“º å®Ÿæ³: ã•ãã€æ–°ãŸãªãƒãƒˆãƒ«ã®é–‹å§‹ã§ã™ï¼');
    console.log(`ğŸ“º å®Ÿæ³: ä»Šå›ã®ãŠé¡Œã¯ã€Œ${JSON.stringify(challenge)}ã€`);
  }

  announceResult(result: ConsciousContent): void {
    const winner = result.winner;
    console.log(`ğŸ“º å®Ÿæ³: å‹è€…ã¯${winner.nickname}é¸æ‰‹ï¼`);
    console.log(`ğŸ“º å®Ÿæ³: è‡ªä¿¡åº¦${(winner.confidence * 100).toFixed(1)}%ã§ã®åœ§å‹ã§ã™ï¼`);

    if (result.competitors.length > 0) {
      console.log('ğŸ“º å®Ÿæ³: æº–å„ªå‹è€…ãŸã¡:');
      result.competitors.forEach((contestant, index) => {
        console.log(`ğŸ“º å®Ÿæ³: ${index + 2}ä½ - ${contestant.nickname} (${(contestant.confidence * 100).toFixed(1)}%)`);
      });
    }
  }
}
```

### 4. è¦³æˆ¦ã‚·ã‚¹ãƒ†ãƒ  - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®åŠ‡å ´

```typescript
// src/components/BattleTheater.tsx - è¦³å®¢å¸­ã‹ã‚‰ãƒãƒˆãƒ«è¦³æˆ¦
export const BattleTheater: React.FC<BattleTheaterProps> = ({
  currentBattle,
  isProcessing
}) => {
  const [spotlight, setSpotlight] = useState({ x: 50, y: 50 });
  const [battleAnimation, setBattleAnimation] = useState('waiting');

  // ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆãŒå‹è€…ã‚’è¿½ã†
  useEffect(() => {
    if (currentBattle) {
      const winnerPosition = getContestantPosition(currentBattle.winner.processorId);
      console.log(`ğŸ’¡ ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ: ${currentBattle.winner.nickname}ã«æ³¨ç›®ï¼`);
      setSpotlight(winnerPosition);
      setBattleAnimation('celebration');
    }
  }, [currentBattle]);

  return (
    <div className="battle-theater bg-gradient-to-b from-indigo-900 via-purple-900 to-pink-900 rounded-xl p-6 min-h-96 relative overflow-hidden">

      {/* åŠ‡å ´ã‚¿ã‚¤ãƒˆãƒ« */}
      <div className="flex items-center space-x-2 mb-6">
        <span className="text-2xl">ğŸ­</span>
        <h2 className="text-xl font-bold text-white">
          ãƒ—ãƒ­ã‚»ãƒƒã‚µã¡ã‚ƒã‚“ãŸã¡ã®ãƒãƒˆãƒ«åŠ‡å ´
        </h2>
        {isProcessing && (
          <div className="animate-pulse text-yellow-400 text-sm">
            â€¢ ãƒãƒˆãƒ«å®Ÿè¡Œä¸­...
          </div>
        )}
      </div>

      {/* ãƒãƒˆãƒ«ã‚¹ãƒ†ãƒ¼ã‚¸ */}
      <div className="relative bg-black/30 rounded-lg min-h-80 overflow-hidden border border-purple-500/30">

        {/* ã‚¹ãƒ†ãƒ¼ã‚¸ç…§æ˜ */}
        <div className="absolute inset-0 bg-gradient-to-t from-purple-800/20 to-transparent" />

        {/* å‹è€…ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ */}
        {currentBattle && (
          <div
            className="absolute w-32 h-32 bg-yellow-300/30 rounded-full blur-2xl transition-all duration-1000 ease-out animate-pulse"
            style={{
              left: `${spotlight.x}%`,
              top: `${spotlight.y}%`,
              transform: 'translate(-50%, -50%)'
            }}
          />
        )}

        {/* é¸æ‰‹é…ç½®ã‚¨ãƒªã‚¢ */}
        <div className="absolute inset-0 p-8">

          {/* ğŸ‘ï¸ è¦–è¦šã¡ã‚ƒã‚“ã®ã‚¨ãƒªã‚¢ */}
          <ContestantArea
            contestant={{
              id: 'vision',
              nickname: 'è¦–è¦šã¡ã‚ƒã‚“',
              icon: 'ğŸ‘ï¸',
              personality: 'perfectionist',
              color: 'blue'
            }}
            position={{ x: 25, y: 30 }}
            isWinner={currentBattle?.winner.processorId === 'vision'}
            isActive={isContestantActive('vision', currentBattle)}
            stats={getContestantStats('vision', currentBattle)}
          />

          {/* ğŸ‘‚ è´è¦šãã‚“ã®ã‚¨ãƒªã‚¢ */}
          <ContestantArea
            contestant={{
              id: 'audio',
              nickname: 'è´è¦šãã‚“',
              icon: 'ğŸ‘‚',
              personality: 'sensitive',
              color: 'green'
            }}
            position={{ x: 75, y: 30 }}
            isWinner={currentBattle?.winner.processorId === 'audio'}
            isActive={isContestantActive('audio', currentBattle)}
            stats={getContestantStats('audio', currentBattle)}
          />

          {/* ğŸ’¬ è¨€èªã•ã‚“ã®ã‚¨ãƒªã‚¢ */}
          <ContestantArea
            contestant={{
              id: 'language',
              nickname: 'è¨€èªã•ã‚“',
              icon: 'ğŸ’¬',
              personality: 'logical',
              color: 'purple'
            }}
            position={{ x: 25, y: 70 }}
            isWinner={currentBattle?.winner.processorId === 'language'}
            isActive={isContestantActive('language', currentBattle)}
            stats={getContestantStats('language', currentBattle)}
          />

          {/* ğŸ§  è¨˜æ†¶ã¡ã‚ƒã‚“ã®ã‚¨ãƒªã‚¢ */}
          <ContestantArea
            contestant={{
              id: 'memory',
              nickname: 'è¨˜æ†¶ã¡ã‚ƒã‚“',
              icon: 'ğŸ§ ',
              personality: 'wise',
              color: 'orange'
            }}
            position={{ x: 75, y: 70 }}
            isWinner={currentBattle?.winner.processorId === 'memory'}
            isActive={isContestantActive('memory', currentBattle)}
            stats={getContestantStats('memory', currentBattle)}
          />

          {/* ä¸­å¤®ãƒãƒˆãƒ«çµæœè¡¨ç¤º */}
          <BattleResultDisplay
            battle={currentBattle}
            isProcessing={isProcessing}
            animation={battleAnimation}
          />
        </div>

        {/* ãƒãƒˆãƒ«ä¸­ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */}
        {isProcessing && (
          <div className="absolute inset-0 bg-gradient-to-r from-yellow-400/5 via-pink-400/5 to-blue-400/5 animate-pulse" />
        )}
      </div>

      {/* ãƒãƒˆãƒ«çµ±è¨ˆ */}
      {currentBattle && (
        <BattleStats battle={currentBattle} />
      )}
    </div>
  );
};

// é¸æ‰‹ã‚¨ãƒªã‚¢ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
const ContestantArea: React.FC<ContestantAreaProps> = ({
  contestant,
  position,
  isWinner,
  isActive,
  stats
}) => {
  const colorClasses = {
    blue: isWinner ? 'border-blue-400 bg-blue-900/50 shadow-lg shadow-blue-400/25' : 'border-blue-600/50 bg-blue-900/20',
    green: isWinner ? 'border-green-400 bg-green-900/50 shadow-lg shadow-green-400/25' : 'border-green-600/50 bg-green-900/20',
    purple: isWinner ? 'border-purple-400 bg-purple-900/50 shadow-lg shadow-purple-400/25' : 'border-purple-600/50 bg-purple-900/20',
    orange: isWinner ? 'border-orange-400 bg-orange-900/50 shadow-lg shadow-orange-400/25' : 'border-orange-600/50 bg-orange-900/20'
  };

  return (
    <div
      className={`absolute p-4 rounded-lg border transition-all duration-500 ${colorClasses[contestant.color]}`}
      style={{
        left: `${position.x}%`,
        top: `${position.y}%`,
        transform: 'translate(-50%, -50%)'
      }}
    >

      {/* é¸æ‰‹æƒ…å ± */}
      <div className="flex items-center space-x-2 mb-2">
        <span className="text-2xl">{contestant.icon}</span>
        <span className="text-white font-medium">{contestant.nickname}</span>
        {isWinner && (
          <span className="text-yellow-400 text-xl animate-bounce">ğŸ†</span>
        )}
      </div>

      {/* æˆ¦ç¸¾è¡¨ç¤º */}
      {stats && (
        <div className="space-y-1">
          <div className="text-xs text-gray-300">
            è‡ªä¿¡åº¦: {(stats.confidence * 100).toFixed(1)}%
          </div>
          <div className="text-xs text-gray-300">
            å‡¦ç†æ™‚é–“: {stats.processingTime}ms
          </div>
          {isWinner && (
            <div className="text-xs text-yellow-400 font-bold animate-pulse">
              ğŸ‰ WINNER!
            </div>
          )}
        </div>
      )}
    </div>
  );
};
```

---

## ğŸ® ãƒãƒˆãƒ«è¦³æˆ¦ãƒ‘ãƒãƒ« - é¸æ‰‹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

### ãƒãƒ£ãƒ¬ãƒ³ã‚¸é€ä¿¡ãƒ‘ãƒãƒ«

```typescript
// src/components/ChallengePanel.tsx - ãƒãƒˆãƒ«æŒ‘æˆ¦çŠ¶é€ä¿¡
export const ChallengePanel: React.FC<ChallengePanelProps> = ({
  onSendChallenge,
  isProcessing,
  isConnected
}) => {
  const [challengeType, setChallengeType] = useState<'single' | 'team'>('single');
  const [selectedContestant, setSelectedContestant] = useState<'vision' | 'audio' | 'language' | 'memory'>('language');
  const [challengeText, setChallengeText] = useState('');
  const [teamChallenge, setTeamChallenge] = useState({
    vision: '',
    audio: '',
    language: '',
    memory: ''
  });

  // æŒ‘æˆ¦çŠ¶é€ä¿¡
  const handleSendChallenge = (e: React.FormEvent) => {
    e.preventDefault();

    if (!isConnected || isProcessing) return;

    if (challengeType === 'team') {
      // ãƒãƒ¼ãƒ æˆ¦ï¼ˆãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«ï¼‰
      const challenges: ProcessorInput[] = [];

      Object.entries(teamChallenge).forEach(([contestant, text]) => {
        if (text.trim()) {
          challenges.push({
            type: contestant as any,
            data: text.trim(),
            timestamp: Date.now()
          });
        }
      });

      if (challenges.length === 0) {
        alert('å°‘ãªãã¨ã‚‚1äººã®é¸æ‰‹ã«æŒ‘æˆ¦çŠ¶ã‚’é€ã£ã¦ã­ï¼');
        return;
      }

      console.log('âš”ï¸ ãƒãƒ¼ãƒ æˆ¦ãƒãƒˆãƒ«é–‹å§‹:', challenges);
      onSendChallenge(challenges);
    } else {
      // å€‹äººæˆ¦
      if (!challengeText.trim()) {
        alert('æŒ‘æˆ¦å†…å®¹ã‚’å…¥åŠ›ã—ã¦ã­ï¼');
        return;
      }

      const challenge: ProcessorInput = {
        type: selectedContestant,
        data: challengeText.trim(),
        timestamp: Date.now()
      };

      console.log(`âš”ï¸ ${selectedContestant}ã¸ã®å€‹äººæˆ¦:`, challenge);
      onSendChallenge(challenge);
    }

    // ãƒ•ã‚©ãƒ¼ãƒ ã‚¯ãƒªã‚¢
    setChallengeText('');
    if (challengeType === 'team') {
      setTeamChallenge({ vision: '', audio: '', language: '', memory: '' });
    }
  };

  return (
    <div className="challenge-panel bg-gradient-to-br from-purple-900/40 to-pink-900/40 backdrop-blur-sm rounded-xl border border-purple-500/20 p-6">
      <h2 className="text-xl font-bold text-white mb-4 flex items-center space-x-2">
        <span className="text-2xl">âš”ï¸</span>
        <span>ãƒãƒˆãƒ«æŒ‘æˆ¦çŠ¶</span>
      </h2>

      <form onSubmit={handleSendChallenge} className="space-y-4">

        {/* ãƒãƒˆãƒ«å½¢å¼é¸æŠ */}
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">
            ãƒãƒˆãƒ«å½¢å¼
          </label>
          <div className="grid grid-cols-2 gap-2">
            <button
              type="button"
              onClick={() => setChallengeType('single')}
              className={`p-3 rounded-lg border text-sm font-medium transition-all ${
                challengeType === 'single'
                  ? 'border-purple-400 bg-purple-900/50 text-purple-200'
                  : 'border-gray-600 bg-gray-800/50 text-gray-300 hover:border-gray-500'
              }`}
            >
              ğŸ¯ å€‹äººæˆ¦
            </button>
            <button
              type="button"
              onClick={() => setChallengeType('team')}
              className={`p-3 rounded-lg border text-sm font-medium transition-all ${
                challengeType === 'team'
                  ? 'border-purple-400 bg-purple-900/50 text-purple-200'
                  : 'border-gray-600 bg-gray-800/50 text-gray-300 hover:border-gray-500'
              }`}
            >
              ğŸ‘¥ ãƒãƒ¼ãƒ æˆ¦
            </button>
          </div>
        </div>

        {/* æŒ‘æˆ¦å†…å®¹å…¥åŠ› */}
        {challengeType === 'single' ? (
          <SingleChallengeForm
            selectedContestant={selectedContestant}
            onContestantChange={setSelectedContestant}
            challengeText={challengeText}
            onTextChange={setChallengeText}
          />
        ) : (
          <TeamChallengeForm
            teamChallenge={teamChallenge}
            onTeamChallengeChange={setTeamChallenge}
          />
        )}

        {/* æŒ‘æˆ¦ä¾‹ãƒœã‚¿ãƒ³ */}
        <ChallengeExamples
          contestantType={challengeType === 'single' ? selectedContestant : null}
          onExampleSelect={(text) => {
            if (challengeType === 'single') {
              setChallengeText(text);
            }
          }}
        />

        {/* é€ä¿¡ãƒœã‚¿ãƒ³ */}
        <button
          type="submit"
          disabled={!isConnected || isProcessing}
          className={`w-full py-3 px-4 rounded-lg font-medium transition-all duration-200 flex items-center justify-center space-x-2 ${
            !isConnected || isProcessing
              ? 'bg-gray-700 text-gray-500 cursor-not-allowed'
              : 'bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white shadow-lg hover:shadow-purple-500/25'
          }`}
        >
          <span className="text-xl">âš”ï¸</span>
          <span>
            {isProcessing
              ? 'ãƒãƒˆãƒ«å®Ÿè¡Œä¸­...'
              : challengeType === 'team'
                ? 'ãƒãƒ¼ãƒ æˆ¦é–‹å§‹ï¼'
                : `${selectedContestant}ã«æŒ‘æˆ¦ï¼`
            }
          </span>
        </button>
      </form>
    </div>
  );
};

// æŒ‘æˆ¦ä¾‹
const challengeExamples = {
  vision: [
    "ç¾ã—ã„å¤•æ—¥ãŒè¦‹ãˆã‚‹",
    "èµ¤ã„è»ŠãŒèµ°ã£ã¦ã„ã‚‹",
    "ã‚­ãƒ©ã‚­ãƒ©å…‰ã‚‹å®çŸ³"
  ],
  audio: [
    "åŠ©ã‘ã¦ï¼ç·Šæ€¥äº‹æ…‹ï¼",
    "ç´ æ•µãªéŸ³æ¥½ãŒèã“ãˆã‚‹",
    "ãƒ‰ãƒ³ãƒ‰ãƒ³å¤§ããªéŸ³ï¼"
  ],
  language: [
    "ä»Šæ—¥ã¯ã¨ã¦ã‚‚ã„ã„å¤©æ°—ã§ã™ã­",
    "æ˜æ—¥ã®ä¼šè­°ã®ä»¶ã«ã¤ã„ã¦",
    "ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™"
  ],
  memory: [
    "æ˜¨æ—¥ã®å‡ºæ¥äº‹",
    "å­ä¾›ã®é ƒã®æ€ã„å‡º",
    "å­¦æ ¡ã§ã®ä½“é¨“"
  ]
};
```

ã“ã®ã‚ˆã†ã«ã€ã‚®ãƒ£ãƒ«é¢¨è§£èª¬ã®æµã‚Œã‚’ç¶™ç¶šã—ã¦ã€è¦–è¦šã¡ã‚ƒã‚“ãƒ»è´è¦šãã‚“ãƒ»è¨€èªã•ã‚“ãƒ»è¨˜æ†¶ã¡ã‚ƒã‚“ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¨­å®šã¨ãƒãƒˆãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’æ´»ã‹ã—ãŸã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è§£èª¬ã«ã—ã¾ã—ãŸï¼ğŸ‰
